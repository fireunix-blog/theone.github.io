<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TheONE&#39;Blog</title>
  
  <subtitle>肉体没有心灵就无法存活</subtitle>
  <link href="https://theone.x-matrix.in/atom.xml" rel="self"/>
  
  <link href="https://theone.x-matrix.in/"/>
  <updated>2022-08-16T17:48:28.415Z</updated>
  <id>https://theone.x-matrix.in/</id>
  
  <author>
    <name>The One</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP数据包分析</title>
    <link href="https://theone.x-matrix.in/network/tcp/tcppacket/"/>
    <id>https://theone.x-matrix.in/network/tcp/tcppacket/</id>
    <published>2022-08-16T02:32:11.000Z</published>
    <updated>2022-08-16T17:48:28.415Z</updated>
    
    <content type="html"><![CDATA[<p>TCP数据包一般也被叫做数据报文，只要使用了TCP协议在设备之间传输数据就会一定遵循TCP数据包格式，这种通用的格式可以保证数据在不同系统、不同设备上以约定好的格式来传输数据。同时TCP处于<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI七层网络模型</a>中的第四层，所以应用层的的协议都是通过四层协议来传输数据的。如果说OSI的三层实现了通过互联网跨机器传输数据，那么可以认为四层实现了传输数据统一格式(通过TCP、UDP等协议)。本篇文章主要分析TCP数据包格式，目的如下:  </p><div class="note purple icon-padding flat"><i class="note-icon fas fa-fan"></i><ol><li>了解并且数据TCP数据包格式</li><li>通过抓包方式分析TCP数据包</li></ol></div><p>用到工具:</p><div class="note orange icon-padding flat"><i class="note-icon fas fa-hand-scissors"></i><ol><li>WireShark: 一般在本地环境分析数据, 支持Mac、Windows、Linux Desktop(Linux Server可以用tshark)</li><li>TCPdump: 一般用在服务端分析数据，用于定位问题，支持Mac、Linux</li></ol></div><h2 id="TCP数据包头"><a href="#TCP数据包头" class="headerlink" title="TCP数据包头"></a>TCP数据包头</h2><div class="note primary flat"><p>TCP数据包格式图</p></div>  <p><img src="/images/tcppacket/tcpheader.png" alt="TCP协议数据头部格式" title="TCP协议数据头部格式">  </p><div class="note info flat"><p>info 代码定义</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TCP头定义，共20个字节 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">short</span> m_sSourPort;                         <span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="type">short</span> m_sDestPort;                         <span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> m_uiSequNum;       　　       <span class="comment">// 序列号32bit</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> m_uiAcknowledgeNum;          <span class="comment">// 确认号32bit</span></span><br><span class="line"> <span class="type">short</span> m_sHeaderLenAndFlag;                <span class="comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span></span><br><span class="line"> <span class="type">short</span> m_sWindowSize;       　　　　　      <span class="comment">// 窗口大小16bit</span></span><br><span class="line"> <span class="type">short</span> m_sCheckSum;        　　　　　       <span class="comment">// 检验和16bit</span></span><br><span class="line"> <span class="type">short</span> m_surgentPointer;      　　　　     <span class="comment">// 紧急数据偏移量16bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头部格式说明"><a href="#头部格式说明" class="headerlink" title="头部格式说明"></a>头部格式说明</h3><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>下面是是头部数据结构总览，后面会对重要字段详细解释。</p></div><p>在TCP头部前20个字节大小固定，为TCP数据包的固定首部。</p><ul><li><p>源端口: 位于TCP数据包头部0-15的位置,占用两个字节,记录了发送数据端套接字端口号。</p></li><li><p>目的端口: 位于TCP数据包头部16-31的位置,占用两个字节,记录了数据接受套接字端口号。</p></li><li><p>报文序号: 位于TCP数据包头部，占用四个字节，也就是32位。使用报文中第一个数据字节的序列号表示报文序列号。</p></li><li><p>确认号: 发送数据方期望收到的数据段序号，用于确认发送方确认报文送达。</p></li><li><p>数据偏移: 也被称为首部长度，占用4位，用来标记TCP协议头部长度。</p></li><li><p>保留字段: 占用6位，为TCP发展预留空间，目前必须全部为0。</p></li><li><p>标志位: 占用6位，用来指示TCP会话中发送发或接受方根据标志位正确处理会话。</p></li><li><p>窗口: 也被称为滑动窗口，占用16位，最大位65535, 告知发送端接收端缓存大小，控制发送端发送速率，控制流量。</p></li><li><p>校验和: 占用两个字节，16位，对TCP报文(包括头部)校验，用于验证数据的正确性。</p></li><li><p>紧急指针: 占用16位，配置URG&#x3D;1时使用，紧急指针声明了紧急数据结束位置，用于发送紧急数据。</p></li><li><p>选项填充: 用于声明TCP报文中的更多信息，长度可变，最大为40字节，在设置完选项后，填充保证头部大小为32的倍数。</p></li></ul><h3 id="报文序号详解"><a href="#报文序号详解" class="headerlink" title="报文序号详解"></a>报文序号详解</h3><div class="note success flat"><p>序号是为了接收方能够按照正确的顺序接受数据</p></div><p> 位于TCP数据包头部，占用四个字节，也就是32位。序号用来标记数据传输顺序，因为不管任何数据类型都会在传输层转换成字节流，举个例子，如果要发送一个字符串<code>Hello</code>，在传输层这个字符串有可能被拆分成两部分字节数据分别传输, 比如上面的字符串被拆分成了<code>He</code>和<code>llo</code>(为了方便解释，这个地方用字符串代替字节)，在实际的传输过程因为用户终端或者是网络设备、环境等因素是无法保证传输顺序正确性，此时数据接收方就会使用这个32位的序号来判断数据传输的顺序(一般在开发中不会关注这些信息，因为操作系统网络栈中实现了数据正确性的校验)。</p><p> 序号的取值范围为2的32次方。在建立的TCP连接中，会为传送的字节流中的每一个字节按照顺序编号，也就是说从建立TCP连接开始到TCP连接端接这个生命周期中，只要涉及到传输数据，数据中的每一个字节都会被编号，这个序号被称为字节序号。  </p><p> 当TCP连接被建立以后，第一个字节数据的序号被称为ISN(Initial Sequence Number), 也就是初始化序号, 初始化的ISN并不一定为1，在RFC中规定，ISN的是根据时间分配的(具体的实现要以操作系统为准)，当操作系统初始化时，存在一个全局变量假设为:<code>g_number</code>会被初始化为1(或者为0)，每个4us加1, 当g_number达到最大值时会被重新初始化为0，当一旦有新的TCP连接创建时，<code>g_number</code>的值就会被赋值给ISN。</p><p> 在整个TCP生命周期中，初始化序号是一个非常重要步骤，双方互相告第一个报文段是谁，TCP之所以被称为是安全的连接，就是通过序号保证了数据传输的安全，TCP三次握手就是为了初始化序号。报文序号只有在下面两种情况中的任意才会存在意义:  </p><ul><li>报文数据字段至少包含一个字节</li><li>报文是SYN段或FIN段或RST段</li></ul><div class="admonition warning"><p class="admonition-title">TCP序列号复用问题</p><p>在TCP中定义的序号位数只有32位，也就是如果在建立的一个会话中传输的数据量大于2的32次方字节，TCP会话会如何序号呢，答案就是复用序号:也就是TCP会话会重置序号，来保证序号仍然保持在2的32次方范围内，但是此时会带来一个问题: 一个高速传输数据的会话中(比如10/40中数据传输速度很快,序号很快就会达到最大值限制)，是如何告知数据接收方该序号是客户端失败重发的序号还是序号重置之后用于发送新数据的序号呢? 在<a href="http://tools.ietf.org/html/rfc1323">RFC 1323</a>提出了PAWS(Protect Against Wrapped Sequence Number)协议，简单的来说就是通过增加了时间戳的方式来保证序号的唯一性(因为时间戳是线性增长的),后面我会单独写一篇文章来了解一些PAWS协议!</p></div><h3 id="报文确认号详解"><a href="#报文确认号详解" class="headerlink" title="报文确认号详解"></a>报文确认号详解</h3><div class="note success flat"><p>确认号是为了让发送方知道接收方已经接收到了数据</p></div><p>在TCP发送端发送数据到接收方之后，发送端每发送一个TCP段，服务端都要回复确认号来表示数据已经收到了来自于发送方的数据。比如发送方发送了报文，其中序列号为:101, 传输的数据为:100字节，如果接收方成功返回确认号，那么服务端就会返回确认号为:201, 表示服务端接下来期望接收字节序号为201以及以后的数据。  </p><p>同时TCP协议支持<code>累计确认</code>的方法: 对于连续传输的报文，可以只对报文中的最后一个TCP段进行确认, 表示确认号之前的数据已经成功接收，比如发送方发送了三个数据包，包1包含字节:0-10, 包2包含字节:11-20, 包3包含的字节:21-20, 那么只要接收方回复了确认号21，就表示包1和包2已经接收成功。 之所以这样设计，是因为数据报文可能会丢失，应答的报文也可能产生丢失，累计确认的目的就是为了避免确认号回复在网络链路中丢失导致数据重新传输。</p><h3 id="数据偏移详解"><a href="#数据偏移详解" class="headerlink" title="数据偏移详解"></a>数据偏移详解</h3><div class="note success flat"><p>数据偏移用来表示报文中传输数据的真实位置</p></div><p>TCP数据包中的数据偏移表示TCP中真正传输的数据距离TCP头部的距离，数据偏移在头部占用<code>4位(0-15)位</code>，单位为32位，也就是四个字节，每一个偏移都可以表示4个字节的偏移。之所以TCP头部存在数据偏移，是因为TCP<code>选项</code>中的内容是根据实际使用情况确定的, 所以TCP头部必须存在数据偏移。数据偏移最大表示为<code>15</code>，每一个偏移都表示为<code>4个字节</code>，所以在一个TCP报文中，最大的偏移量为:<code>15*4=60字节</code>(其中前20个偏移量是固定的)。TCP首部长度范围在:<code>20-60字节</code>之间。同时选项中数据长度不固定并且偏移量是以<code>4字节</code>为一个单位的，所以在填充中必须在在填充之后和选项内容为<code>32的倍数</code>(这里是位为单位，也就是<code>4字节</code>的倍数)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP数据包一般也被叫做数据报文，只要使用了TCP协议在设备之间传输数据就会一定遵循TCP数据包格式，这种通用的格式可以保证数据在不同系统、不同设备上以约定好的格式来传输数据。同时TCP处于&lt;a href=&quot;https://zh.wikipedia.org/wiki/OSI</summary>
      
    
    
    
    <category term="network" scheme="https://theone.x-matrix.in/categories/network/"/>
    
    <category term="tcp" scheme="https://theone.x-matrix.in/categories/network/tcp/"/>
    
    
    <category term="TCP" scheme="https://theone.x-matrix.in/tags/TCP/"/>
    
    <category term="网络" scheme="https://theone.x-matrix.in/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="系统" scheme="https://theone.x-matrix.in/tags/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="数据包" scheme="https://theone.x-matrix.in/tags/%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
    
    <category term="分析" scheme="https://theone.x-matrix.in/tags/%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
