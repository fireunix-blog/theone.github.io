<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP数据包分析</title>
      <link href="//network/tcp/tcppacket/"/>
      <url>//network/tcp/tcppacket/</url>
      
        <content type="html"><![CDATA[<p><script src="/assets/asciinema-player.js"></script><link rel="stylesheet" type="text/css" href="/assets/asciinema-player.css" /><br>TCP数据包一般也被叫做数据报文，只要使用了TCP协议在设备之间传输数据就会一定遵循TCP数据包格式，这种通用的格式可以保证数据在不同系统、不同设备上以约定好的格式来传输数据。同时TCP处于<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI七层网络模型</a>中的第四层，所以应用层的的协议都是通过四层协议来传输数据的。如果说OSI的三层实现了通过互联网跨机器传输数据，那么可以认为四层实现了传输数据统一格式(通过TCP、UDP等协议)。本篇文章主要分析TCP数据包格式，目的如下:<br><div class="note purple icon-padding flat"><i class="note-icon fas fa-fan"></i><ol><li>了解并且数据TCP数据包格式</li><li>通过抓包方式分析TCP数据包</li></ol></div><br>用到工具:<br><div class="note orange icon-padding flat"><i class="note-icon fas fa-hand-scissors"></i><ol><li>WireShark: 一般在本地环境分析数据, 支持Mac、Windows、Linux Desktop(Linux Server可以用tshark)</li><li>TCPdump: 一般用在服务端分析数据，用于定位问题，支持Mac、Linux</li></ol></div></p><h2 id="TCP数据包头"><a href="#TCP数据包头" class="headerlink" title="TCP数据包头"></a>TCP数据包头</h2><div class="note primary flat"><p>TCP数据包格式图</p></div>  <p><img src="/images/tcppacket/tcpheader.png" alt="TCP协议数据头部格式" title="TCP协议数据头部格式"><br><div class="note info flat"><p>info 代码定义</p></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TCP头定义，共20个字节 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">short</span> m_sSourPort;                         <span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="type">short</span> m_sDestPort;                         <span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> m_uiSequNum;       　　       <span class="comment">// 序列号32bit</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> m_uiAcknowledgeNum;          <span class="comment">// 确认号32bit</span></span><br><span class="line"> <span class="type">short</span> m_sHeaderLenAndFlag;                <span class="comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span></span><br><span class="line"> <span class="type">short</span> m_sWindowSize;       　　　　　      <span class="comment">// 窗口大小16bit</span></span><br><span class="line"> <span class="type">short</span> m_sCheckSum;        　　　　　       <span class="comment">// 检验和16bit</span></span><br><span class="line"> <span class="type">short</span> m_surgentPointer;      　　　　     <span class="comment">// 紧急数据偏移量16bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="头部格式说明"><a href="#头部格式说明" class="headerlink" title="头部格式说明"></a>头部格式说明</h3><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>下面是是头部数据结构总览，后面会对重要字段详细解释。</p></div><p>在TCP头部前20个字节大小固定，为TCP数据包的固定首部。</p><ul><li>源端口: 位于TCP数据包头部0-15的位置,占用两个字节,记录了发送数据端套接字端口号。</li></ul><ul><li>目的端口: 位于TCP数据包头部16-31的位置,占用两个字节,记录了数据接受套接字端口号。</li></ul><ul><li>报文序号: 位于TCP数据包头部，占用四个字节，也就是32位。使用报文中第一个数据字节的序列号表示报文序列号。</li></ul><ul><li>确认号: 发送数据方期望收到的数据段序号，用于确认发送方确认报文送达。</li></ul><ul><li>数据偏移: 也被称为首部长度，占用4位，用来标记TCP协议头部长度。</li></ul><ul><li>保留字段: 占用6位，为TCP发展预留空间，<del>目前必须全部为0</del>，老版tcp头部预留6位，新版预留3位。</li></ul><ul><li>标志位: 占用6位，用来指示TCP会话中发送发或接受方根据标志位正确处理会话。</li></ul><ul><li>窗口: 也被称为滑动窗口，占用16位，最大位65535, 告知发送端接收端缓存大小，控制发送端发送速率，控制流量。</li></ul><ul><li>校验和: 占用两个字节，16位，对TCP报文(包括头部)校验，用于验证数据的正确性。</li></ul><ul><li>紧急指针: 占用16位，配置URG=1时使用，紧急指针声明了紧急数据结束位置，用于发送紧急数据。</li></ul><ul><li>选项填充: 用于声明TCP报文中的更多信息，长度可变，最大为40字节，在设置完选项后，填充保证头部大小为32的倍数。</li></ul><h3 id="报文序号详解"><a href="#报文序号详解" class="headerlink" title="报文序号详解"></a>报文序号详解</h3><div class="note success flat"><p>序号是为了接收方能够按照正确的顺序接受数据。</p></div><p> 位于TCP数据包头部，占用四个字节，也就是32位。序号用来标记数据传输顺序，因为不管任何数据类型都会在传输层转换成字节流，举个例子，如果要发送一个字符串<code>Hello</code>，在传输层这个字符串有可能被拆分成两部分字节数据分别传输, 比如上面的字符串被拆分成了<code>He</code>和<code>llo</code>(为了方便解释，这个地方用字符串代替字节)，在实际的传输过程因为用户终端或者是网络设备、环境等因素是无法保证传输顺序正确性，此时数据接收方就会使用这个32位的序号来判断数据传输的顺序(一般在开发中不会关注这些信息，因为操作系统网络栈中实现了数据正确性的校验)。</p><p> 序号的取值范围为2的32次方。在建立的TCP连接中，会为传送的字节流中的每一个字节按照顺序编号，也就是说从建立TCP连接开始到TCP连接端接这个生命周期中，只要涉及到传输数据，数据中的每一个字节都会被编号，这个序号被称为字节序号。  </p><p> 当TCP连接被建立以后，第一个字节数据的序号被称为ISN(Initial Sequence Number), 也就是初始化序号, 初始化的ISN并不一定为1，在RFC中规定，ISN的是根据时间分配的(具体的实现要以操作系统为准)，当操作系统初始化时，存在一个全局变量假设为:<code>g_number</code>会被初始化为1(或者为0)，每个4us加1, 当g_number达到最大值时会被重新初始化为0，当一旦有新的TCP连接创建时，<code>g_number</code>的值就会被赋值给ISN。</p><p> 在整个TCP生命周期中，初始化序号是一个非常重要步骤，双方互相告第一个报文段是谁，TCP之所以被称为是安全的连接，就是通过序号保证了数据传输的安全，TCP三次握手就是为了初始化序号。报文序号只有在下面两种情况中的任意才会存在意义:  </p><ul><li>报文数据字段至少包含一个字节</li><li>报文是SYN段或FIN段或RST段</li></ul><div class="admonition warning"><p class="admonition-title">TCP序列号复用问题</p><p>在TCP中定义的序号位数只有32位，也就是如果在建立的一个会话中传输的数据量大于2的32次方字节，TCP会话会如何序号呢，答案就是复用序号:也就是TCP会话会重置序号，来保证序号仍然保持在2的32次方范围内，但是此时会带来一个问题: 一个高速传输数据的会话中(比如10/40中数据传输速度很快,序号很快就会达到最大值限制)，是如何告知数据接收方该序号是客户端失败重发的序号还是序号重置之后用于发送新数据的序号呢? 在<a href="http://tools.ietf.org/html/rfc1323">RFC 1323</a>提出了PAWS(Protect Against Wrapped Sequence Number)协议，简单的来说就是通过增加了时间戳的方式来保证序号的唯一性(因为时间戳是线性增长的),后面我会单独写一篇文章来了解一些PAWS协议!</p></div><h3 id="报文确认号详解"><a href="#报文确认号详解" class="headerlink" title="报文确认号详解"></a>报文确认号详解</h3><div class="note success flat"><p>确认号是为了让发送方知道接收方已经接收到了数据。</p></div><p>在TCP发送端发送数据到接收方之后，发送端每发送一个TCP段，服务端都要回复确认号来表示数据已经收到了来自于发送方的数据。比如发送方发送了报文，其中序列号为:101, 传输的数据为:100字节，如果接收方成功返回确认号，那么服务端就会返回确认号为:201, 表示服务端接下来期望接收字节序号为201以及以后的数据。  </p><p>同时TCP协议支持<code>累计确认</code>的方法: 对于连续传输的报文，可以只对报文中的最后一个TCP段进行确认, 表示确认号之前的数据已经成功接收，比如发送方发送了三个数据包，包1包含字节:0-10, 包2包含字节:11-20, 包3包含的字节:21-20, 那么只要接收方回复了确认号21，就表示包1和包2已经接收成功。 之所以这样设计，是因为数据报文可能会丢失，应答的报文也可能产生丢失，累计确认的目的就是为了避免确认号回复在网络链路中丢失导致数据重新传输。</p><h3 id="数据偏移详解"><a href="#数据偏移详解" class="headerlink" title="数据偏移详解"></a>数据偏移详解</h3><div class="note success flat"><p>数据偏移用来表示报文中传输数据的真实位置。</p></div><p>TCP数据包中的数据偏移表示TCP中真正传输的数据距离TCP头部的距离，数据偏移在头部占用<code>4位(0-15)位</code>，单位为32位，也就是四个字节，每一个偏移都可以表示4个字节的偏移。之所以TCP头部存在数据偏移，是因为TCP<code>选项</code>中的内容是根据实际使用情况确定的, 所以TCP头部必须存在数据偏移。数据偏移最大表示为<code>15</code>，每一个偏移都表示为<code>4个字节</code>，所以在一个TCP报文中，最大的偏移量为:<code>15*4=60字节</code>(其中前20个偏移量是固定的)。TCP首部长度范围在:<code>20-60字节</code>之间。同时选项中数据长度不固定并且偏移量是以<code>4字节</code>为一个单位的，所以在填充中必须在在填充之后和选项内容为<code>32的倍数</code>(这里是位为单位，也就是<code>4字节</code>的倍数)。</p><h3 id="报文标志位"><a href="#报文标志位" class="headerlink" title="报文标志位"></a>报文标志位</h3><div class="note success flat"><p>报文标志位是非常重要的内容，一个TCP会话建立连接到数据传输到最终连接关闭都离不开标志位参与。</p></div><p>在TCP传输中每个TCP报文都会有一个目的，至于是什么目的就需要借助TCP标志位来确定，比如TCP在握手、挥手、传输数据过程中每个标志位也是不一样的。</p><ul><li><p><span class='p gray'>URG:</span> 紧急指针，该Flag需要配合16位紧急指针一起使用，其中指针数据用来指示数据包中紧急数据中最后一个字节的下一个字节，也就说当启用了URG之后，会通知接受方数据包中从0开始到指针指向位置结束的内容为紧急数据, 接收方接受到紧急数据会将该数据保存到单独的缓冲区，并且告知应用程序有紧急数据可用，应用程序可以通过设置<code>recv(int sockfd, void *buf, size_t len, int flags)</code>方法中的<code>flags</code>标志位来读取这些紧急数据。在FTP协议中用到了URG，FTP即可以执行命令也可以传输数据，如果FTP一直忙于传输数据就会导致命令阻塞，通过设置URG状态，系统会中断数据传输，通知FTP服务接受到了紧急数据。除此之外，URG使用的情况很少，大部分应用程序是不支持的。</p></li><li><p><span class='p green'>ACK:</span> 该Flag用于通知发送方接收方已经接收到了发送方发送的数据，在大多数情况下，对于发送或接受的每个数据包，都做进行确认。</p></li><li><span class='p red'>PSH:</span> 在了解PSH Flag之前必须简单了解一下MTU、MSS、窗口和TCP中缓冲区运行机制，区分MTU、MSS、窗口作用: <div class="tabs" id="mtu"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mtu-1">MTU</button></li><li class="tab"><button type="button" data-href="#mtu-2">MSS</button></li><li class="tab"><button type="button" data-href="#mtu-3">窗口</button></li><li class="tab"><button type="button" data-href="#mtu-4">TCP缓冲区</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mtu-1"><p>MTU(Maximum Transmission Unit)是指网络层(第三层)中传输的最大数据报单元，MTU一般由数据链路层(二层)设备决定。简单的来说就是物理接口提供给上层最大一次传输数据的大小。比如在以太网中，默认MTU的值为1500字节，如果在三层要发送的IP数据包大于1500字节，则必须把IP数据包进行分片传输，如果发送的IP数据包小于等于1500字节，那么就只需要一个数据包就可以完成发送。这里需要特别注意的有三点:</p><ul><li>传输层提供的是一种不可靠的传输方式，也就是在传输过程中丢失了一个包，传输层无法发现丢失的这个包，应用层即使发现传输失败，也只能重传整个IP包。</li><li>MTU可以被被修改，但是无论设备是处于二层还是处于三层，都需要配置端到端沿途所有的设备，IP包只要大于沿途中任何一个设备的MTU，那么设备就会把IP包做分片处理<img src="/images/tcppacket/mtu.jpeg" alt="MTU分片"></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-2"><p>MSS(Maximum Segment Size)是指数据传输层(第四层)数据报文中payload的长度，在MTU=1500字节的网络上传输数据是，MSS=1500-IP头部长度-TCP头部长度。该功能实现了传输层分片功能。当TCP层要传输的数据大于MSS时，传输的数据就会被分片传输。之所以存在MSS，目的就是实现四层对数据分片，避免数据在三层分片。举个例子: 如果一个数据包为10000，在不使用MSS的情况下，该数据会在三层拆分多个包发送，如果传输过程中一个包丢失，长度为10000的整个数据包就会重新传输。如果使用了MSS，该数据就会在四层分片，因为四层中TCP协议实现了安全传输，丢失其中任意分片的数据，四层都可以重新传输，从而大大降低因为丢包导致整个数据需要重新传输的代价。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-3"><p>TCP滑动窗口用来告知发送方接收端缓存大小，控制发送端发送的速度，可以简单的理解为: 接收端告诉发送端我还有多少缓冲空间可以使用，你发送的数据量不要超过我的缓冲空间。必须明白的是窗口和MUT、MSS没有任何关系，MTU和MSS用来控制每次传输单元长度，滑动窗口用来协商双方发送数据量问题。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-4"><p>在上面的偏移量<a href="#数据偏移详解">数据偏移详解</a>中可以得知，一个TCP头部最小为20个字节，同样的一个IP头部也占用20个字节，如果每次传输的数据量太小，比如每次传输只有1个字节, IP头部长度20个字节，假设TCP头部长度也是20字节，那么在一次传输中一共要传输41个字节，这对于网络来说是一种巨大的浪费。如果在传输数据时以大量小包方式传输，整个网络宽带就会被挤占， 同时接受和发送端所在的操作系统也不得不处理每一个数据包(这种<a href="https://blog.csdn.net/realmardrid/article/details/122857586">攻击手法</a>也是众多DDOS攻击手法中的一种常见攻击方式)。 为了增加网络吞吐量，一般操作系统都有相应的算法优化小包发送方式, 以Linux中的<a href="https://zh.m.wikipedia.org/zh/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95">Nagle</a>为例, 优化小包规则如下:</p><ul><li>如果数据包长度达到了MSS, 则允许发送缓冲区数据;</li><li>如果数据包中含有FIN标志，则允许发送缓冲区数据;</li><li>如果设置了TCP_NODELAY选项，则允许发送缓冲区数据;</li><li>没有设置TCP_CORK选项，并且所有发出去的包都被确认，则允许发送缓冲区数据;</li><li>数据已经缓冲区等待了一定的时间(一般是200ms)，则允许发送缓冲区数据;</li><li>数据被标记为紧急数据，则允许发送缓冲区数据;</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>综上来说，PSH标记是为了告知TCP模块不要再等待缓冲区数据写入或者继续等待发送周期，而是直接将数据发送(发送方)或者将数据推送给上层应用程序(接受方)。<br>对于发送方来说，一般每一次使用write方法写入数据到缓冲区，都会将缓冲区的数据打包成一个或者多个TCP报文，并且设置最后一个TCP报文的PSH标志位，从而告知TCP立即发送缓冲区的数据。 对于接受方来说，如果接受到的数据报文中包含PSH标志，则会立即将数据从缓冲区推送给上层应用。</p></li><li><p><span class='p cyan'>RST:</span> 复位标志, 在正常断开一个已连接的TCP会话的情况下，过程需要四次挥手。 但是在异常情况下双方通讯一定存在问题，导致正常的四次挥手这个过程无法正常执行，RST Flag的出现提供了强制关闭连接的一种机制。正常情况下，无论是发送方的数据包还是接收方的数据包中包含<code>RST</code>标记，该TCP会话申请的内存和端口等资源都会被系统释放，对于上层的应用来说，就是TCP连接被关闭了，一般会显示<code>connection reset</code>或者<code>connection refused</code>的错误信息。在目前的操作系统中，为了保证系统内核的安全性，一般是把应用和内核分开，每个应用的内存分为 <code>用户空间</code> 和<code>内核空间</code>。在网络通讯中，客户端和服务端一般都属于应用层，应用层只能通过<code>send/recv</code>的系统调用与内核交互，才能感知到内核的网络会话域是否接受到了<code>RST</code>。 当一端收到了另外一端发送的<code>RST</code>后，内核会认为会话连接已经关闭。如果<code>应用层</code>的应用再次尝试使用<code>recv</code>去读取数据，应用层就会收到<code>Connection reset by peer</code>的错误，表示另外一端已经把连接关闭，如果尝试使用<code>send</code>把数据写入内核缓冲区，应用层就会收到<code>Broken pipe</code>的错误，表示会话已经断开了连接。 下面是几种经常出现<code>RST</code>的情况: </p></li></ul><div class="tabs" id="mtu"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mtu-1">端口不可用</button></li><li class="tab"><button type="button" data-href="#mtu-2">请求超时</button></li><li class="tab"><button type="button" data-href="#mtu-3">套接字设置了l_linger和l_onoff</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mtu-1"><p>端口不可用一般可能是因为端口没有监听过，也有可能是监听端口的应用已经退出，操作系统系统回收掉了应用程序申请的资源。无论是上面的哪种情况，操作系统接收到请求后就会根据请求目的IP和端口遍历操作系统中会话资源, 如果根据IP和端口没有找到指定的对象，一般情况下就会给请求方返回一个包含<code>RST</code>的数据包。但是需要注意的是如果在TCP传输的过程中数据包被篡改，也就是原始数据包发送的<code>校验和</code>和接受到的数据中的<code>校验和</code>不一致，那么TCP报文会被操作系统直接丢弃，不会返回包含<code>RST</code>的数据包。这是一个连<code>校验和</code>检测都没有通过的数据包，多半是有问题的，该数据包大概率是在传输过程中被篡改了，或者是一个伪造的数据包，因为在正常的传输层，一般应用的两种协议中: TCP丢弃<code>检验和</code>有问题的包后，对方长时间收不到<code>ACK</code>回复的情况下会自动尝试重传，另外一种协议UDP本身就是一个不可靠传输协议，如果检测到数据包有问题，就会直接丢弃。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-2"><p>TCP协议中提供了超时选项，如果接收方所在的IP地址能够ping通过，并且端口正常监听，排除防火墙问题，如果在接收到包含<code>RST</code>的数据包，有大概率的问题就是设置了TCP超时选项，当设置了TCP超时选项后并且没有在指定的超时时间内收到数据，此时设置超时的一方就会发送一个<code>RST</code>标志的数据包给对方，表示拒绝对方连接。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-3"><p>正常关闭TCP连接的过程中要经历四次挥手的操作，在应用层调用<code>close()</code>关闭连接时，会发送<code>FIN</code>标志给对方，默认情况下，<code>close()</code>会立马返回，此时内核中的TCP模块负责将缓存区中的数据发送给对方，但是对于应用层来说，无法感知到缓冲区的数据是否发送完成，<code>l_linger</code>选项可以控制应用调用<code>close()</code>之后的行为。</p><ol><li>使用默认的参数情况下，也就是<code>l_onoff</code>为0，<code>l_linger</code>值被忽略，调用<code>close()</code>之后会立即返回给调用者，TCP模块负责发送残留的的缓冲区数据给对方。</li><li>当<code>l_onoff</code>为1, <code>l_linger</code>为0的情况下，TCP回直接丢弃缓冲区数据，并发送<code>RST</code>给对方，此时不会再按照四次挥手关闭连接，同时对方调用<code>recv()</code>也会出现<code>WSAECONNRESET</code>错误。</li><li>当<code>l_onoff</code>为1，<code>l_linger</code>&gt;0，并且socket为阻塞，则调用<code>close()</code>将阻塞<code>l_linger</code>秒时间，如果在<code>l_linger</code>秒内缓冲区数据成功发送,<code>close()</code>将会返回0,如果未能成功发送缓冲区数据,<code>close()</code>返回-1,表示失败, 并将<code>errno</code>设置为EWOILDBLCOK。</li><li>当socket为非阻塞时, <code>close()</code>将立即返回，需要根据<code>close()</code>返回值以及<code>errno</code>来判断TCP缓冲区是否发送成功。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>需要注意的是，传输过程中如果出现数据包错误错误是不会发送<code>RST</code>标志的，也就是原始数据包发送的<code>校验和</code>和接受到的数据中的<code>校验和</code>不一致，那么TCP报文会被操作系统直接丢弃，不会返回包含<code>RST</code>的数据包。这是一个连<code>校验和</code>检测都没有通过的数据包，多半是有问题的，该数据包大概率是在传输过程中被篡改了，或者是一个伪造的数据包，因为在正常的传输层，一般应用的两种协议中: TCP丢弃<code>检验和</code>有问题的包后，对方长时间收不到<code>ACK</code>回复的情况下会自动尝试重传，另外一种协议UDP本身就是一个不可靠传输协议，如果检测到数据包有问题，就会直接丢弃。</p><ul><li><span class='p blue'>SYN:</span> SYN(Synchronize Sequence Numbers)被程序同步序号编号，该Flag用于初始化TCP连接，TCP连接可以理解为于远程的机器建立一个虚拟电路(类似于二层中设备通过物理电路连接)， 当客户端发起对服务端连接时，会在数据包中设置<code>SYN</code>标记，服务端回复的包中也会设置<code>SYN</code>标记，最后客户端回复给服务端中的不再设置<code>SYN</code>标记，此时三次握手结束(后面我会单独写一篇文章介绍TCP中的三次握手和四次挥手)。 </li></ul><p>与该标记相关的一种攻击手法就是<code>SYN Flood攻击</code>，也被称为<code>SYN洪水攻击</code>，原理就是描述就是: 客服端向服务端连接请求，此时数据报文中的<code>SYN</code>标记被设置，服务端返回一个包含SYN+ACK的报文给客户端，并等待客户端再次发送包含<code>ACK</code>标记的报文等待完成三次握手这个过程，此时如果客户端不回复<code>ACK</code>报文，则服务端会认为之前发出的报文丢失，并且会重新发送一遍包含<code>SYN+ACK</code>的报文返回客户端并等待一端时间，如果等待后仍然没有收到客户端发来包含<code>ACK</code>标记的报文，服务端就会丢弃这个未完成的连接，中间等待的这段时间被称为<code>SYN Timeout</code>,一般来说等待的这段时间是分钟数量级别的，如果一个系统存在这种大量的<code>半连接</code>，就不得不花大量的资源维护在操作系统中，加上服务端不断的对<code>半链接</code>进行回复重试，服务端的负载最终将会变得异常巨大，此时由于服务器忙于维持这种半连接会无暇理睬正常用户的请求或者响应客户请求很慢，从正常请求的的用户来看，服务端就是响应缓慢或者无响应。  </p><p>另外一种对<code>SYN</code>常见的用法就是<code>SYN扫描</code>, 正常扫描端口是客户端和服务端之间建立一个连接(完成三次握手)来判断目标是否开启了指定端口，正常三次握手之后，服务端应用能够获取到客户端的信息，如果服务端发现某个客户端进行大量的不同端口的连接就可以非常简单的判断是否有扫描器在扫描自己。但是客户端在发送SYN请求到服务端之后，可以直接根据服务端返回的响应信息是<code>RST</code>还是<code>SYN+ACK</code>就可以判断出目标端口是否存活，不需要完成三次握手过程。此时客户端在服务端响应后直接发送<code>RST</code>标记的数据包返回给服务端结束连接就可以了，此过程中上层应用无法感知到是否存在客户端连接, 比如Nmap扫描器就支持<a href="https://nmap.org/man/zh/man-port-scanning-techniques.html">SYN扫描</a>。</p><ul><li><span class='p yellow'>FIN:</span> FIN Flag表示连接终止符，用于四次挥手这个过程，建立一个连接需要三次握手，断开一个连接需要四次挥手。和上面三次握手中，TCP提供了<code>半连接(half-open)</code>的特性一样，TCP关闭连接同样提供了<code>半关闭(half-close)</code>的特性, <code>半关闭</code>这个特性主要是为了解决在TCP中的一端关闭掉发送数据之后还能继续接收对端发送数据的能力，下面是简单的四次挥手过程(后面我会写一篇详细的文章介绍三次握手和四次挥手):</li></ul><ol><li>客户端发送一个<code>FIN报文</code>, 并且停止再次发送数据，并且客户端此时处于<code>FIN-WAIT1</code>的状态，等待服务端来确认。</li><li>服务端收到<code>FIN报文</code>后，会响应<code>ACK</code>报文，表示已经收到客户端要关闭连接的的报文了，服务端此时处于<code>CLOSE-WAIT</code>状态。</li><li>客户端收到服务端<code>ACK</code>报文后，进入到<code>FIN-WAIT2</code>的状态，等待服务端最终确认关闭连接。</li><li>如果服务端想要断开连接(不再向客户端发送数据)，此时服务端也向客户端发送一个<code>FIN报文</code>, 此时服务端处于一个<code>LAST-ACK</code>的状态，等待客户端的确认。</li><li>客户端收到服务端的<code>FIN报文</code>后，也会一样发送一个ACK报文作为应答，此时客户端处于<code>TIMNE-WAIT</code>状态，并在计时器指定时间周期后关闭连接，服务端收到ACK报文后也将关闭连接。</li></ol><h3 id="扩展标标志位"><a href="#扩展标标志位" class="headerlink" title="扩展标标志位"></a>扩展标标志位</h3><div class="note success flat"><p>在2001年9月的<code>RFC3168</code>的文档中启用了3位TCP保留位，实现了显示拥塞通知。</p></div><p>还记得前面图中TCP头部保留字段保留了6位么？<a href="#头部格式说明">TCP头部</a>。在2001年9月的<code>RFC3168</code>中定义了新版的TCP头部(该头部兼容老版头部定义)。新版本的头部使用了保留字段中的三位用来扩展TCP协议。新增加了<code>NS</code>, <code>CWR</code>, <code>ECE</code>标志位。这三个标志位需要一起配合使用，简称<code>ECN</code>，三个标志位定义位置如图所示:<img src="/images/tcppacket/extend-tcpheader.png" alt="TCP头部扩展"><br><code>ECN(Explicit Congestion Notification)</code>简称显示拥塞通知，支持端到端的网络拥塞通知。<br>在通常情况下，一旦网络中出现拥塞，TCP/IP会主动丢弃数据包，源端检测到丢包后就会减小拥塞窗口，降低传输速率，如果端到端能够成功协商<code>ECN</code>的话。支持<code>ECN</code>的路由器就可以在发生拥塞时在IP报头中设置一个标记，发出一个即将拥塞的信号，而不是直接丢弃数据包。<code>ENC</code>减少了TCP的丢包数量，通过避免重传，较少了延迟(尤其是抖动), 提升了网络传输效率。由于<code>ENC</code>定义比较复杂，我后面会写一篇新的文章来介绍<code>ECN</code>。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><div class="note success flat"><p>滑动窗口告知发送方接收方还能接受最大的数据量，后面我会单独写一篇文章介绍介绍TCP中的滑动窗口。</p></div><p>每个TCP会话中，无论接收方还是发送方，系统都初始化了一块内存区域来保存接收或者发送的数据。我们一般叫这块内存区域为内存缓冲区。  </p><p>在TCP会话中，发送方接收到另外一方发送的数据之后，会回复<code>ACK</code>响应，然后发送方继续发送一下一个数据包。但是这种效率明显会很低效，第一个原因是考虑到发送端需要在每次在发送数据之后等待接收端的<code>ACK</code>确认，确认也是需要网络延时成本的。第二个原因就是如果接收端接收到数据后所在主机如果忙于处理其他事情有可能会导致<code>ACK</code>不能及时回复。  </p><p>鉴于这种情况，TCP引入了<code>窗口</code>的概念，<code>窗口大小</code>就是指：无需等待接受端<code>ACK</code>恢复，可以继续发送数据量的最大值。前面说到了，在每个TCP会话中，系统都会初始化一块内存用来保存接收和发送的数据，<code>窗口大小</code>就是系统中这块内存剩余的空间，对于发送方来说，通过得知对方的<code>窗口大小</code>就可以知道还能发送给接收方的的最大数据量是多少。如果尝试发送数据量大于接收方的内存缓冲区，则接收方会丢弃掉该来自于接收方的数据。 对于发送方来说，发送缓存也是一块内存区域，该内存也有大小。 如果尝试写入的数据量大于该内存空间大小, 会导致上层应用的<code>send()</code>方法一直处于阻塞状态。  </p><p>另外需要注意的是，发送方发送的数据虽然可以在<code>ACK</code>确认之前多次发送，但是已发送的数据在收到对应<code>ACK</code>确认之前仍然会保留在内存缓冲区，在按期收到<code>ACK</code>确认之后，数据就可以缓冲区清除。  </p><p>另外TCP支持<code>累计确认</code>，比如发送方发送了数据为: 100-199, 200-299, 300-399 这三段数据，只要接受方回复了<code>ACK</code>为400的结果，就认为 100-199, 200-299, 300-399这三段数据已经全部发送成功。</p><h3 id="TCP校验和"><a href="#TCP校验和" class="headerlink" title="TCP校验和"></a>TCP校验和</h3><p>TCP校验和属于端到端的一种校验方式，发送的每个数据包都由发送端计算出校验和，然后放在TCP头部，然后接收端接收到数据之后再次计算校验和是否一致，如果TCP会话中发送的数据包在中途被修改过，接收端会直接丢弃TCP报文。 TCP校验和校验包含IP的首部信息，然后把伪首部、TCP报头、TCP数据化为2个字节长度，如果总字节总长度为奇数，那么就在最后添加一个每位位都为0的字节。需要注意的是TCP报头中包含校验码信息，在计算校验和的过程中，校验码每位都是0，否则会陷入校验码计算的逻辑混乱中。</p><p>伪首部需要依赖三层数据报头中的信息，包括: 源IP地址(32位)、目的IP地址(32位)、保留字节(8位)、传输协议(8位)、TCP报文长度(包含报头+数据)。之所以TCP校验和用到三层的内容，主要是为了进一步TCP校验和的检错能力，因为有了伪首部的参与，TCP校验和相当于增加了对源和目的IP地址、传输协议等内容的检测。</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
          <category> tcp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络 </tag>
            
            <tag> 系统 </tag>
            
            <tag> 数据包 </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
