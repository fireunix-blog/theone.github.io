<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP数据包分析</title>
      <link href="//network/tcp/tcppacket/"/>
      <url>//network/tcp/tcppacket/</url>
      
        <content type="html"><![CDATA[<p>TCP数据包一般也被叫做数据报文，只要使用了TCP协议在设备之间传输数据就会一定遵循TCP数据包格式，这种通用的格式可以保证数据在不同系统、不同设备上以约定好的格式来传输数据。同时TCP处于<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI七层网络模型</a>中的第四层，所以应用层的的协议都是通过四层协议来传输数据的。如果说OSI的三层实现了通过互联网跨机器传输数据，那么可以认为四层实现了传输数据统一格式(通过TCP、UDP等协议)。本篇文章主要分析TCP数据包格式，目的如下:<br><div class="note purple icon-padding flat"><i class="note-icon fas fa-fan"></i><ol><li>了解并且数据TCP数据包格式</li><li>通过抓包方式分析TCP数据包</li></ol></div><br>用到工具:<br><div class="note orange icon-padding flat"><i class="note-icon fas fa-hand-scissors"></i><ol><li>WireShark: 一般在本地环境分析数据, 支持Mac、Windows、Linux Desktop(Linux Server可以用tshark)</li><li>TCPdump: 一般用在服务端分析数据，用于定位问题，支持Mac、Linux</li></ol></div></p><h2 id="TCP数据包头"><a href="#TCP数据包头" class="headerlink" title="TCP数据包头"></a>TCP数据包头</h2><div class="note primary flat"><p>TCP数据包格式图</p></div>  <p><img src="/images/tcppacket/tcpheader.png" alt="TCP协议数据头部格式" title="TCP协议数据头部格式"><br><div class="note info flat"><p>info 代码定义</p></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TCP头定义，共20个字节 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">short</span> m_sSourPort;                         <span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="type">short</span> m_sDestPort;                         <span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> m_uiSequNum;       　　       <span class="comment">// 序列号32bit</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> m_uiAcknowledgeNum;          <span class="comment">// 确认号32bit</span></span><br><span class="line"> <span class="type">short</span> m_sHeaderLenAndFlag;                <span class="comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span></span><br><span class="line"> <span class="type">short</span> m_sWindowSize;       　　　　　      <span class="comment">// 窗口大小16bit</span></span><br><span class="line"> <span class="type">short</span> m_sCheckSum;        　　　　　       <span class="comment">// 检验和16bit</span></span><br><span class="line"> <span class="type">short</span> m_surgentPointer;      　　　　     <span class="comment">// 紧急数据偏移量16bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="头部格式说明"><a href="#头部格式说明" class="headerlink" title="头部格式说明"></a>头部格式说明</h3><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>下面是是头部数据结构总览，后面会对重要字段详细解释。</p></div><p>在TCP头部前20个字节大小固定，为TCP数据包的固定首部。</p><ul><li>源端口: 位于TCP数据包头部0-15的位置,占用两个字节,记录了发送数据端套接字端口号。</li></ul><ul><li>目的端口: 位于TCP数据包头部16-31的位置,占用两个字节,记录了数据接受套接字端口号。</li></ul><ul><li>报文序号: 位于TCP数据包头部，占用四个字节，也就是32位。使用报文中第一个数据字节的序列号表示报文序列号。</li></ul><ul><li>确认号: 发送数据方期望收到的数据段序号，用于确认发送方确认报文送达。</li></ul><ul><li>数据偏移: 也被称为首部长度，占用4位，用来标记TCP协议头部长度。</li></ul><ul><li>保留字段: 占用6位，为TCP发展预留空间，目前必须全部为0。</li></ul><ul><li>标志位: 占用6位，用来指示TCP会话中发送发或接受方根据标志位正确处理会话。</li></ul><ul><li>窗口: 也被称为滑动窗口，占用16位，最大位65535, 告知发送端接收端缓存大小，控制发送端发送速率，控制流量。</li></ul><ul><li>校验和: 占用两个字节，16位，对TCP报文(包括头部)校验，用于验证数据的正确性。</li></ul><ul><li>紧急指针: 占用16位，配置URG=1时使用，紧急指针声明了紧急数据结束位置，用于发送紧急数据。</li></ul><ul><li>选项填充: 用于声明TCP报文中的更多信息，长度可变，最大为40字节，在设置完选项后，填充保证头部大小为32的倍数。</li></ul><h3 id="报文序号详解"><a href="#报文序号详解" class="headerlink" title="报文序号详解"></a>报文序号详解</h3><div class="note success flat"><p>序号是为了接收方能够按照正确的顺序接受数据</p></div><p> 位于TCP数据包头部，占用四个字节，也就是32位。序号用来标记数据传输顺序，因为不管任何数据类型都会在传输层转换成字节流，举个例子，如果要发送一个字符串<code>Hello</code>，在传输层这个字符串有可能被拆分成两部分字节数据分别传输, 比如上面的字符串被拆分成了<code>He</code>和<code>llo</code>(为了方便解释，这个地方用字符串代替字节)，在实际的传输过程因为用户终端或者是网络设备、环境等因素是无法保证传输顺序正确性，此时数据接收方就会使用这个32位的序号来判断数据传输的顺序(一般在开发中不会关注这些信息，因为操作系统网络栈中实现了数据正确性的校验)。</p><p> 序号的取值范围为2的32次方。在建立的TCP连接中，会为传送的字节流中的每一个字节按照顺序编号，也就是说从建立TCP连接开始到TCP连接端接这个生命周期中，只要涉及到传输数据，数据中的每一个字节都会被编号，这个序号被称为字节序号。  </p><p> 当TCP连接被建立以后，第一个字节数据的序号被称为ISN(Initial Sequence Number), 也就是初始化序号, 初始化的ISN并不一定为1，在RFC中规定，ISN的是根据时间分配的(具体的实现要以操作系统为准)，当操作系统初始化时，存在一个全局变量假设为:<code>g_number</code>会被初始化为1(或者为0)，每个4us加1, 当g_number达到最大值时会被重新初始化为0，当一旦有新的TCP连接创建时，<code>g_number</code>的值就会被赋值给ISN。</p><p> 在整个TCP生命周期中，初始化序号是一个非常重要步骤，双方互相告第一个报文段是谁，TCP之所以被称为是安全的连接，就是通过序号保证了数据传输的安全，TCP三次握手就是为了初始化序号。报文序号只有在下面两种情况中的任意才会存在意义:  </p><ul><li>报文数据字段至少包含一个字节</li><li>报文是SYN段或FIN段或RST段</li></ul><div class="admonition warning"><p class="admonition-title">TCP序列号复用问题</p><p>在TCP中定义的序号位数只有32位，也就是如果在建立的一个会话中传输的数据量大于2的32次方字节，TCP会话会如何序号呢，答案就是复用序号:也就是TCP会话会重置序号，来保证序号仍然保持在2的32次方范围内，但是此时会带来一个问题: 一个高速传输数据的会话中(比如10/40中数据传输速度很快,序号很快就会达到最大值限制)，是如何告知数据接收方该序号是客户端失败重发的序号还是序号重置之后用于发送新数据的序号呢? 在<a href="http://tools.ietf.org/html/rfc1323">RFC 1323</a>提出了PAWS(Protect Against Wrapped Sequence Number)协议，简单的来说就是通过增加了时间戳的方式来保证序号的唯一性(因为时间戳是线性增长的),后面我会单独写一篇文章来了解一些PAWS协议!</p></div><h3 id="报文确认号详解"><a href="#报文确认号详解" class="headerlink" title="报文确认号详解"></a>报文确认号详解</h3><div class="note success flat"><p>确认号是为了让发送方知道接收方已经接收到了数据</p></div><p>在TCP发送端发送数据到接收方之后，发送端每发送一个TCP段，服务端都要回复确认号来表示数据已经收到了来自于发送方的数据。比如发送方发送了报文，其中序列号为:101, 传输的数据为:100字节，如果接收方成功返回确认号，那么服务端就会返回确认号为:201, 表示服务端接下来期望接收字节序号为201以及以后的数据。  </p><p>同时TCP协议支持<code>累计确认</code>的方法: 对于连续传输的报文，可以只对报文中的最后一个TCP段进行确认, 表示确认号之前的数据已经成功接收，比如发送方发送了三个数据包，包1包含字节:0-10, 包2包含字节:11-20, 包3包含的字节:21-20, 那么只要接收方回复了确认号21，就表示包1和包2已经接收成功。 之所以这样设计，是因为数据报文可能会丢失，应答的报文也可能产生丢失，累计确认的目的就是为了避免确认号回复在网络链路中丢失导致数据重新传输。</p><h3 id="数据偏移详解"><a href="#数据偏移详解" class="headerlink" title="数据偏移详解"></a>数据偏移详解</h3><div class="note success flat"><p>数据偏移用来表示报文中传输数据的真实位置</p></div><p>TCP数据包中的数据偏移表示TCP中真正传输的数据距离TCP头部的距离，数据偏移在头部占用<code>4位(0-15)位</code>，单位为32位，也就是四个字节，每一个偏移都可以表示4个字节的偏移。之所以TCP头部存在数据偏移，是因为TCP<code>选项</code>中的内容是根据实际使用情况确定的, 所以TCP头部必须存在数据偏移。数据偏移最大表示为<code>15</code>，每一个偏移都表示为<code>4个字节</code>，所以在一个TCP报文中，最大的偏移量为:<code>15*4=60字节</code>(其中前20个偏移量是固定的)。TCP首部长度范围在:<code>20-60字节</code>之间。同时选项中数据长度不固定并且偏移量是以<code>4字节</code>为一个单位的，所以在填充中必须在在填充之后和选项内容为<code>32的倍数</code>(这里是位为单位，也就是<code>4字节</code>的倍数)。</p><h3 id="报文标志位"><a href="#报文标志位" class="headerlink" title="报文标志位"></a>报文标志位</h3><p>在TCP传输中每个TCP报文都会有一个目的，至于是什么目的就需要借助TCP标志位来确定，比如TCP在握手、挥手、传输数据过程中每个标志位也是不一样的。</p><ul><li><p><span class='p gray'>URG:</span> 紧急指针，该Flag需要配合16位紧急指针一起使用，其中指针数据用来指示数据包中紧急数据中最后一个字节的下一个字节，也就说当启用了URG之后，会通知接受方数据包中从0开始到指针指向位置结束的内容为紧急数据, 接收方接受到紧急数据会将该数据保存到单独的缓冲区，并且告知应用程序有紧急数据可用，应用程序可以通过设置<code>recv(int sockfd, void *buf, size_t len, int flags)</code>方法中的<code>flags</code>标志位来读取这些紧急数据。在FTP协议中用到了URG，FTP即可以执行命令也可以传输数据，如果FTP一直忙于传输数据就会导致命令阻塞，通过设置URG状态，系统会中断数据传输，通知FTP服务接受到了紧急数据。除此之外，URG使用的情况很少，大部分应用程序是不支持的。</p></li><li><p><span class='p green'>ACK:</span> 该Flag用于通知发送方接收方已经接收到了发送方发送的数据，在大多数情况下，对于发送或接受的每个数据包，都做进行确认。</p></li><li><span class='p red'>PSH:</span> 在了解PSH Flag之前必须简单了解一下MTU、MSS、窗口和TCP中缓冲区运行机制，区分MTU、MSS、窗口作用: <div class="tabs" id="mtu"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mtu-1">MTU</button></li><li class="tab"><button type="button" data-href="#mtu-2">MSS</button></li><li class="tab"><button type="button" data-href="#mtu-3">窗口</button></li><li class="tab"><button type="button" data-href="#mtu-4">TCP缓冲区</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mtu-1"><p>MTU(Maximum Transmission Unit)是指网络层(第三层)中传输的最大数据报单元，MTU一般由数据链路层(二层)设备决定。简单的来说就是物理接口提供给上层最大一次传输数据的大小。比如在以太网中，默认MTU的值为1500字节，如果在三层要发送的IP数据包大于1500字节，则必须把IP数据包进行分片传输，如果发送的IP数据包小于等于1500字节，那么就只需要一个数据包就可以完成发送。这里需要特别注意的有三点:</p><ul><li>传输层提供的是一种不可靠的传输方式，也就是在传输过程中丢失了一个包，传输层无法发现丢失的这个包，应用层即使发现传输失败，也只能重传整个IP包。</li><li>MTU可以被被修改，但是无论设备是处于二层还是处于三层，都需要配置端到端沿途所有的设备，IP包只要大于沿途中任何一个设备的MTU，那么设备就会把IP包做分片处理<img src="/images/tcppacket/mtu.jpeg" alt="MTU分片"></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-2"><p>MSS(Maximum Segment Size)是指数据传输层(第四层)数据报文中payload的长度，在MTU=1500字节的网络上传输数据是，MSS=1500-IP头部长度-TCP头部长度。该功能实现了传输层分片功能。当TCP层要传输的数据大于MSS时，传输的数据就会被分片传输。之所以存在MSS，目的就是实现四层对数据分片，避免数据在三层分片。举个例子: 如果一个数据包为10000，在不使用MSS的情况下，该数据会在三层拆分多个包发送，如果传输过程中一个包丢失，长度为10000的整个数据包就会重新传输。如果使用了MSS，该数据就会在四层分片，因为四层中TCP协议实现了安全传输，丢失其中任意分片的数据，四层都可以重新传输，从而大大降低因为丢包导致整个数据需要重新传输的代价。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-3"><p>TCP滑动窗口用来告知发送方接收端缓存大小，控制发送端发送的速度，可以简单的理解为: 接收端告诉发送端我还有多少缓冲空间可以使用，你发送的数据量不要超过我的缓冲空间。必须明白的是窗口和MUT、MSS没有任何关系，MTU和MSS用来控制每次传输单元长度，滑动窗口用来协商双方发送数据量问题。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mtu-4"><p>在上面的偏移量<a href="#数据偏移详解">数据偏移详解</a>中可以得知，一个TCP头部最小为20个字节，同样的一个IP头部也占用20个字节，如果每次传输的数据量太小，比如每次传输只有1个字节, IP头部长度20个字节，假设TCP头部长度也是20字节，那么在一次传输中一共要传输41个字节，这对于网络来说是一种巨大的浪费。如果在传输数据时以大量小包方式传输，整个网络宽带就会被挤占， 同时接受和发送端所在的操作系统也不得不处理每一个数据包(这种<a href="https://blog.csdn.net/realmardrid/article/details/122857586">攻击手法</a>也是众多DDOS攻击手法中的一种常见攻击方式)。 为了增加网络吞吐量，一般操作系统都有相应的算法优化小包发送方式, 以Linux中的<a href="https://zh.m.wikipedia.org/zh/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95">Nagle</a>为例, 优化小包规则如下:</p><ul><li>如果数据包长度达到了MSS, 则允许发送缓冲区数据;</li><li>如果数据包中含有FIN标志，则允许发送缓冲区数据;</li><li>如果设置了TCP_NODELAY选项，则允许发送缓冲区数据;</li><li>没有设置TCP_CORK选项，并且所有发出去的包都被确认，则允许发送缓冲区数据;</li><li>数据已经缓冲区等待了一定的时间(一般是200ms)，则允许发送缓冲区数据;</li><li>数据被标记为紧急数据，则允许发送缓冲区数据;</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>综上来说，PSH标记是为了告知TCP模块不要再等待缓冲区数据写入或者继续等待发送周期，而是直接将数据发送(发送方)或者将数据推送给上层应用程序(接受方)。<br>对于发送方来说，一般每一次使用write方法写入数据到缓冲区，都会将缓冲区的数据打包成一个或者多个TCP报文，并且设置最后一个TCP报文的PSH标志位，从而告知TCP立即发送缓冲区的数据。 对于接受方来说，如果接受到的数据报文中包含PSH标志，则会立即将数据从缓冲区推送给上层应用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
          <category> tcp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络 </tag>
            
            <tag> 系统 </tag>
            
            <tag> 数据包 </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
